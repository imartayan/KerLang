(** C code generator - To transpile to C. *)

open Kl_IR

let emit_header oc =
  Printf.fprintf oc "
/*----------------------------------------------------*/
/* This code is generated by the KerLang compiler and */
/* is not intended to be manually edited              */
/*----------------------------------------------------*/

#include <stdlib.h> /* exit, EXIT_FAILURE */
#include <stdio.h> /* printf, fprintf */

static inline int out(int x0, int x1)
{
    printf(\"%%d\\n\", x0);
    return x1;
}
static inline int add(int x0, int x1)
{
    return x0 + x1;
}
static inline int sub(int x0, int x1)
{
    return x0 - x1;
}
static inline int mul(int x0, int x1)
{
    return x0 * x1;
}
static inline int div(int x0, int x1)
{
    if (x1 == 0)
    {
        fprintf(stderr, \"Division by zero fatal error: aborting.\\n\");
        exit(EXIT_FAILURE);
    }
    return x0 / x1;
}
\n"

let emit_indent oc (indent_lvl : int) =
  for _ = 0 to indent_lvl - 1 do
    Printf.fprintf oc "    "
  done

let emit_param_sequence oc (params_count : int) = 
  for i = 0 to params_count - 2 do
    Printf.fprintf oc "int x%d, " i
  done;
  if params_count >= 1 then begin
    Printf.fprintf oc "int x%d" (params_count - 1)
  end else begin
    Printf.fprintf oc "void"
  end

let rec emit_ast oc ?(self_name : string option = None) ?(indent_lvl : int = 0) (func : ast) =
  match func with
  | Cst value ->
    Printf.fprintf oc "\n%a%d" emit_indent indent_lvl value
  | Var id ->
    Printf.fprintf oc "\n%ax%d" emit_indent indent_lvl id
  | App (op, args) ->
    Printf.fprintf oc "\n%a%a(%a)"
      emit_indent indent_lvl
      (emit_op ~self_name) op
      (emit_ast_list ~self_name ~indent_lvl:(indent_lvl + 1)) args
  | If (cond, ifcase, elsecase) ->
    Printf.fprintf oc "%a ?%a :%a"
      (emit_ast ~self_name ~indent_lvl:(indent_lvl)) cond
      (emit_ast ~self_name ~indent_lvl:(indent_lvl)) ifcase
      (emit_ast ~self_name ~indent_lvl:(indent_lvl)) elsecase

and emit_ast_list oc ?(self_name : string option = None) ?(indent_lvl : int = 0) (ast_list : ast list) =
  match ast_list with
  | [] -> ()
  | ast::[] ->
    emit_ast oc ~self_name:(self_name) ~indent_lvl:(indent_lvl) ast
  | ast::q ->
    emit_ast oc ~self_name:(self_name) ~indent_lvl:(indent_lvl) ast;
    Printf.fprintf oc ", ";
    emit_ast_list oc ~self_name:(self_name) ~indent_lvl:(indent_lvl) q

and emit_op oc ?(self_name : string option = None) (op: op) =
  match op with
  | OUT ->
    Printf.fprintf oc "out";
  | ADD ->
    Printf.fprintf oc "add"
  | SUB ->
    Printf.fprintf oc "sub"
  | MUL ->
    Printf.fprintf oc "mul"
  | DIV ->
    Printf.fprintf oc "div"
  | FUN name ->
    Printf.fprintf oc "%s" name
  | SELF ->
    match self_name with
    | None -> Kl_errors.dev_error "self_name needed but not provided"
    | Some name -> Printf.fprintf oc "%s" name

let emit_ast_as_function_decl oc ?(indent_lvl : int = 0) (name : string) (func : ast) =
  emit_indent oc indent_lvl;
  Printf.fprintf oc "int %s(%a)\n{\n%areturn%a;\n}\n\n"
    name
    emit_param_sequence (ast_count_params func)
    emit_indent (indent_lvl + 1)
    (emit_ast ~indent_lvl:(indent_lvl + 2) ~self_name:(Some name)) func

let emit_entrypoint_call oc = 
  Printf.fprintf oc "%s" "\n"